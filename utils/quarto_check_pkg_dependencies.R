# This script is used to manage the Quarto cache generated by the freeze: auto/true
# execute option. It removes entries from the cache if the package dependencies
# have changed since the last time the cache was generated.
#
# This script should be called by quarto before rendering, as below:
# project:
#   pre-render: "utils/quarto_check_pkg_dependencies.R"
here::i_am("utils/quarto_check_pkg_dependencies.R")
library(dplyr, warn.conflicts = FALSE)
library(fs)
library(here)
library(purrr)
library(readr)
library(renv, warn.conflicts = FALSE)
library(stringr)

message("Checking package versions against previous executions...")

# All QMD files in the project, get file paths and dependencies
qmd_files <- dir_ls(here(), recurse = TRUE, type ="file", glob = "*.qmd")

# The QMD files that do (or could) use python, cross joined to every
# python package. Current renv dependencies don't check for python, so
# assume that every python script uses every python package
python_deps <-
  read_lines(here("requirements.txt")) |> 
  tibble(package_version = _) |> 
  mutate(
    package = str_extract(package_version, "^[^=]+"),
    # hash is really just a version string, but have like this for compatibility
    # with the renv hash
    hash = str_extract(package_version, "[^=]+$"),
    .keep = "none"
  ) |> 
  cross_join(tibble(full_path = str_subset(qmd_files, fixed("python"))))

# Get current RENV dependencies of each QMD file
# For each package in those dependencies, get the current package hash
qmd_deps <- 
  dependencies(qmd_files) |> 
  # dependencies produces duplicates
  distinct() |> 
  select(full_path = Source, package = Package) |> 
  left_join(
    # Get package hashes from the renv lockfile
    lockfile_read()$Packages |>
      map(\(x) pluck(x, "Hash")) |>
      unlist() |>
      as_tibble(rownames = "package") |> 
      rename(hash = value),
    join_by(package)
  ) |> 
  # Add all python packages/dependencies
  bind_rows(python_deps) |>
  mutate(
    # Path local to project root
    local_path = str_replace(full_path, fixed(str_c(here(), "/")), ""),
    # Some R packages will have a hash of NA if they are base/recommended,
    # so add a string for the R version instead
    hash = coalesce(hash, as.character(getRversion()))
  ) |> 
  select(local_path, package, hash) |>
  # Sort for easier diffs in CSV output 
  arrange(local_path, package)

# Load old dependencies from CSV (if it exists)
if (file_exists(here("data/quarto_pkg_dependencies.csv"))) {
  old_qmd_deps <- read_csv(here("data/quarto_pkg_dependencies.csv"), col_types = "ccc")
} else {
  # If no previous cache, treat as if we had no files or hashes
  old_qmd_deps <- qmd_deps[0,]
}

# Compare the old and new dependencies
diff <- 
  qmd_deps |> 
  full_join(
    # Before full join, remove all files that no longer exist
    semi_join(old_qmd_deps, qmd_deps, "local_path"),
    join_by(local_path, package)
  ) |> 
  # Check for any files where we have new or removed packages, or where
  # the hash has changed
  filter(
      is.na(hash.x) |
      is.na(hash.y) |
      hash.x != hash.y
  ) |> 
  # Any entries left are now files where something has changed, so have to
  # remove the quarto freeze cache
  select(local_path) |> 
  distinct() |> 
  mutate(freeze_path = here("_freeze", path_ext_remove(local_path))) |> 
  pull(freeze_path) |> 
  walk(
    \(x) {
      if (dir_exists(x)) {
        message("Dependencies changed, removing cache at: ", x)
        dir_delete(x)
      }
    }
  )

# Write the current dependencies to CSV
message("Saving current package versions to data/quarto_pkg_dependencies.csv")
write_csv(qmd_deps, here("data/quarto_pkg_dependencies.csv"))
