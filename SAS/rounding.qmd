---
title: "Rounding in SAS"
execute: 
  eval: false
---

There are two rounding functions in SAS.

The `**round()**` function in SAS will round to the nearest whole number and 'away from zero' or 'rounding up' when equidistant meaning that exactly 12.5 rounds to the integer 13.

The `**rounde()*`* function in SAS will round to the nearest whole number and 'rounding to the even number' when equidistant, meaning that exactly 12.5 rounds to the integer 12.

Both functions allow you to specify the number of decimal places you want to round to.

For example (See references for source of the example)


```{r}
#| include: false

library(sasquatch)
sasquatch::sas_connect()

```


```{r}
#| include: false

widget_01 <- sasquatch::sas_run_string(
  "
data XXX;
    input my_number;
    datalines;
    2.2
    3.99
    1.2345
    7.876
    13.8739
    ;

data xxx2;
    set xxx;
    do decimal_places = 1, 2, 3;
        round_result = round(my_number, 10**(-decimal_places));
        rounde_result = rounde(my_number, decimal_places);
        output;
    end;
run;

proc print data=xxx2;
run;
",
  capture = "listing"
)

saveRDS(widget_01, "rds/rounding/widget_01.rds")
```

```txt
data XXX;
    input my_number;
    datalines;
    2.2
    3.99
    1.2345
    7.876
    13.8739
    ;

data xxx2;
    set xxx;
    do decimal_places = 1, 2, 3;
        round_result = round(my_number, 10**(-decimal_places));
        rounde_result = rounde(my_number, decimal_places);
        output;
    end;
run;

proc print data=xxx2;
run;
```


```{r}
#| echo: false
#| eval: true
readRDS(file = "rds/rounding/widget_01.rds")
```


In some rare cases, `round()` does not return result as expected. For example below.

```{r}
#| include: false

widget_02 <- sasquatch::sas_run_string(
  "
data floating_point_precision;
    /* Example 1: Large number precision loss */
    input_val = 32768.0156255;
    expected =  32768.015626;
    actual = round(input_val, 1e-6);
    difference = actual - expected;
    example = 'Large number';
    output;
    
    /* Example 2: Subtraction then rounding */
    input_val = 2048.1375 - 2048;  /* = 0.1375 */
    expected = 0.138;
    actual = round(input_val, 1e-3);
    difference = actual - expected;
    example = 'After subtraction';
    output;
run;

proc print data=floating_point_precision;
    format input_val expected actual difference 13.8;
    var example input_val expected actual difference;
run;
",
  capture = "listing"
)
saveRDS(widget_02, file = "rds/rounding/widget_02.rds")
```

```txt
data floating_point_precision;
    /* Example 1: Large number precision loss */
    input_val = 32768.0156255;
    expected =  32768.015626;
    actual = round(input_val, 1e-6);
    difference = actual - expected;
    example = 'Large number';
    output;
    
    /* Example 2: Subtraction then rounding */
    input_val = 2048.1375 - 2048;  /* = 0.1375 */
    expected = 0.138;
    actual = round(input_val, 1e-3);
    difference = actual - expected;
    example = 'After subtraction';
    output;
run;

proc print data=floating_point_precision;
    format input_val expected actual difference 13.8;
    var example input_val expected actual difference;
run;
```


```{r}
#| echo: false
#| eval: true
readRDS(file = "rds/rounding/widget_02.rds")
```

You can find a little more by the code below. It creates dummy numbers with different numbers of decimal digits, and filter incorrect results. Note, the incorrect results are expected when the input number is near or beyond the precision level, i.e. the last decimal of the input number is near or less than the number multiplied by `constant('maceps')`.

```{r}
#| include: false

widget_03 <- sasquatch::sas_run_string(
  "
data dum1;
    int1=0; output;
    do i=1 to 25;
      int1=2**i; output;
    end;
    keep int1;
run;

data dum2;
    do round_digits=1 to 7;
      *x.xxx5 should be rounded up, or replace 5 to 4.99 which should be rounded down;
      dec1=2**(-round_digits)+10**(-round_digits-1)*5;
      output;
    end;
    keep dec1 round_digits;
run;

proc sql;
    create table incorrect_round2(where=(rounded<num1)) as
    select dum1.*,dum2.*,int1+dec1 as num1,round(calculated num1,10**(-round_digits)) as rounded
    from dum1, dum2;
proc print;
quit;
",
  capture = "listing"
)
saveRDS(widget_03, file = "rds/rounding/widget_03.rds")
```

```txt
data dum1;
    int1=0; output;
    do i=1 to 25;
      int1=2**i; output;
    end;
    keep int1;
run;

data dum2;
    do round_digits=1 to 7;
      *x.xxx5 should be rounded up, or replace 5 to 4.99 which should be rounded down;
      dec1=2**(-round_digits)+10**(-round_digits-1)*5;
      output;
    end;
    keep dec1 round_digits;
run;

proc sql;
    create table incorrect_round2(where=(rounded<num1)) as
    select dum1.*,dum2.*,int1+dec1 as num1,round(calculated num1,10**(-round_digits)) as rounded
    from dum1, dum2;
proc print;
quit;
```


```{r}
#| echo: false
#| eval: true
readRDS("rds/rounding/widget_03.rds")
```


Or more by the code below and comparing with results from another language, e.g. R.

```{r}
#| include: false

widget_04 <- sasquatch::sas_run_string(
  "

data simple;
    input num1 num2;
    datalines;
    3.14159 2.71828
    1.99999 0.33333
    5.55555 4.44444
    7.87654 1.23456
    0.12345 9.87654
    6.66666 3.33333
    ;
run;

data results;
    set simple;
    operator='+'; num3=num1+num2; output;
    operator='-'; num3=num1-num2; output;
    operator='*'; num3=num1*num2; output;
    operator='/'; num3=num1/num2; output;
run;

data final;
    set results;
    rounded_001 = round(num3, 0.001);  /* Round to nearest 0.001 */
    rounded_01  = round(num3, 0.01);   /* Round to nearest 0.01 */
    rounded_1   = round(num3, 0.1);    /* Round to nearest 0.1 */
    rounded_int = round(num3, 1);      /* Round to nearest integer */
run;

proc print data=final;
    format num1 num2 num3 rounded_001 rounded_01 rounded_1 rounded_int 12.6;
run;
",
  capture = "listing"
)
saveRDS(widget_04, file = "rds/rounding/widget_04.rds")
```

```txt
data simple;
    input num1 num2;
    datalines;
    3.14159 2.71828
    1.99999 0.33333
    5.55555 4.44444
    7.87654 1.23456
    0.12345 9.87654
    6.66666 3.33333
    ;
run;

data results;
    set simple;
    operator='+'; num3=num1+num2; output;
    operator='-'; num3=num1-num2; output;
    operator='*'; num3=num1*num2; output;
    operator='/'; num3=num1/num2; output;
run;

data final;
    set results;
    rounded_001 = round(num3, 0.001);  /* Round to nearest 0.001 */
    rounded_01  = round(num3, 0.01);   /* Round to nearest 0.01 */
    rounded_1   = round(num3, 0.1);    /* Round to nearest 0.1 */
    rounded_int = round(num3, 1);      /* Round to nearest integer */
run;

proc print data=final;
    format num1 num2 num3 rounded_001 rounded_01 rounded_1 rounded_int 12.6;
run;
```


```{r}
#| echo: false
#| eval: true
readRDS(file = "rds/rounding/widget_04.rds")
```


As the incorrect rounding all occur on large number, `round()` is still reliable in most of cases.

**References**

[How to Round Numbers in SAS - SAS Example Code](https://sasexamplecode.com/how-to-round-numbers-in-sas/)
