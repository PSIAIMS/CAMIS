{
  "hash": "bd2f6501555b922af19afa1c7e24ba4e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Skewness/Kurtosis\"\noutput: html_document\n---\n\n\n# **Skewness and Kurtosis in Python**\n\nSkewness measures the the amount of asymmetry in a distribution, while Kurtosis describes the \"tailedness\" of the curve.\nThese measures are frequently used to assess the normality of the data.\nThere are several methods to calculate these measures. In Python, the packages **pandas**, **scipy.stats.skew** and **scipy.stats.kurtosis** can be used.\n\n## Data Used\n\n::: {#87ca3260 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nfrom scipy.stats import skew, kurtosis\n\n# Create sample data\ndata = {\n    'team': [\"A\"]*5 + [\"B\"]*5 + [\"C\"]*5,\n    'points': [10, 17, 17, 18, 15, 10, 14, 13, 29, 25, 12, 30, 34, 12, 11],\n    'assists': [2, 5, 6, 3, 0, 2, 5, 4, 0, 2, 1, 1, 3, 4, 7]\n}\ndf = pd.DataFrame(data)\n```\n:::\n\n\n#### Skewness \n\nJoanes and Gill (1998) discusses three methods for estimating skewness:\n\n-   Type 1: This is the typical definition used in many older textbooks\n\n$$g_1 = m_1/m_2^{3/2}$$\n\n-   Type 2: Used in SAS and SPSS\n\n    $$\n    G_1 = g_1\\sqrt{n(n-1)}/(n-2)\n    $$\n\n-   Type 3: Used in MINITAB and BMDP\n\n    $$\n    b_1 = m_3/s^3 = g_1((n-1)/n)^{3/2}\n    $$\n\nAll three skewness measures are unbiased under normality. The three methods are illustrated in the following code:\n\n::: {#68230d67 .cell message='false' execution_count=2}\n``` {.python .cell-code}\n# Skewness\ntype1_skew = skew(df['points'])\ntype2_skew = df['points'].skew()\ntype3_skew = skew(df['points']) * ((len(df['points']) - 1) / len(df['points'])) ** (3/2)\n\nprint(f\"Skewness - Type 1: {type1_skew}\")\nprint(f\"Skewness - Type 2: {type2_skew}\")\nprint(f\"Skewness - Type 3: {type3_skew}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSkewness - Type 1: 0.9054442043798532\nSkewness - Type 2: 1.0093179298709385\nSkewness - Type 3: 0.816426058828937\n```\n:::\n:::\n\n\nThe default for the **scipy.stats.skew** function is type 1.\n\n#### Kurtosis\n\nJoanes and Gill (1998) discuss three methods for estimating kurtosis:\n\n-   Type 1: This is the typical definition used in many older textbooks\n\n$$g_2 = m_4/m_2^{2}-3$$\n\n-   Type 2: Used in SAS and SPSS\n\n    $$G_2 = ((n+1)g_2+6)*\\frac{(n-1)}{(n-2)(n-3)}$$\n\n-   Type 3: Used in MINITAB and BMDP\n\n    $$b_2 = m_4/s^4-3 = (g_2 + 3)(1-1/n)^2-3$$\n\nOnly $G_2$ (corresponding to type 2) is unbiased under normality. The three methods are illustrated in the following code:\n\n::: {#ace34f17 .cell message='false' execution_count=3}\n``` {.python .cell-code}\n# Kurtosis\ntype1_kurt = kurtosis(df['points'])\n\nn = len(df['points'])\ng2 = kurtosis(df['points'], fisher=True)  # Fisher's kurtosis\n\n# Calculate the kurtosis type using the formula G2\ntype2_kurt = ((n + 1) * g2 + 6) * ((n - 1) / ((n - 2) * (n - 3)))\n\n# Calculate the kurtosis type using the formula b2\nn = len(df['points'])\ng2 = kurtosis(df['points'], fisher=True)  # Fisher's kurtosis\n\ntype3_kurt = (g2 + 3) * ((1 - 1/n) ** 2) - 3\n\nprint(f\"Kurtosis - Type 1: {type1_kurt}\")\nprint(f\"Kurtosis - Type 2: {type2_kurt}\")\nprint(f\"Kurtosis - Type 3: {type3_kurt}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKurtosis - Type 1: -0.5833410771247833\nKurtosis - Type 2: -0.2991564184355863\nKurtosis - Type 3: -0.8948215605175891\n```\n:::\n:::\n\n\nThe default for the **scipy.stats.kurtosis** function is type 1.\n\n",
    "supporting": [
      "skewness_kurtosis_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}