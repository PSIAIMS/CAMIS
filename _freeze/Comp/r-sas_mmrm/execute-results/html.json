{
  "hash": "163b960e98f33a06de8e61c27ba72d9f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R vs SAS MMRM\"\n---\n\n\n\n\n\n\n\n\n\n\n\n# Introduction\n\nIn this vignette we briefly compare the `mmrm::mmrm`, SAS's `PROC GLIMMIX`, `nlme::gls`, `lme4::lmer`, and `glmmTMB::glmmTMB` functions for fitting mixed models for repeated measures (MMRMs). A primary difference in these implementations lies in the covariance structures that are supported \"out of the box\". In particular, `PROC GLIMMIX` and `mmrm` are the only procedures which provide support for many of the most common MMRM covariance structures. Most covariance structures can be implemented in `gls`, though users are required to define them manually. `lmer` and `glmmTMB` are more limited. We find that `mmmrm` converges more quickly than other R implementations while also producing estimates that are virtually identical to `PROC GLIMMIX`'s.\n\n# Datasets\n\nTwo datasets are used to illustrate model fitting with the `mmrm`, `lme4`, `nlme`, `glmmTMB` R packages as well as `PROC GLIMMIX`. These data are also used to compare these implementations' operating characteristics.\n\n## FEV Data\n\nThe FEV dataset contains measurements of FEV1 (forced expired volume in one second), a measure of how quickly the lungs can be emptied. Low levels of FEV1 may indicate chronic obstructive pulmonary disease (COPD). It is summarized below.\n\n```         \n                                      Stratified by ARMCD\n                               Overall       PBO           TRT\n  n                              800           420           380\n  USUBJID (%)\n     PT[1-200]                   200           105 (52.5)     95 (47.5)\n  AVISIT\n     VIS1                        200           105            95\n     VIS2                        200           105            95\n     VIS3                        200           105            95\n     VIS4                        200           105            95\n  RACE (%)\n     Asian                       280 (35.0)    152 (36.2)    128 (33.7)\n     Black or African American   300 (37.5)    184 (43.8)    116 (30.5)\n     White                       220 (27.5)     84 (20.0)    136 (35.8)\n  SEX = Female (%)               424 (53.0)    220 (52.4)    204 (53.7)\n  FEV1_BL (mean (SD))          40.19 (9.12)  40.46 (8.84)  39.90 (9.42)\n  FEV1 (mean (SD))             42.30 (9.32)  40.24 (8.67)  44.45 (9.51)\n  WEIGHT (mean (SD))            0.52 (0.23)   0.52 (0.23)   0.51 (0.23)\n  VISITN (mean (SD))            2.50 (1.12)   2.50 (1.12)   2.50 (1.12)\n  VISITN2 (mean (SD))          -0.02 (1.03)   0.01 (1.07)  -0.04 (0.98)\n```\n\n## BCVA Data\n\nThe BCVA dataset contains data from a randomized longitudinal ophthalmology trial evaluating the change in baseline corrected visual acuity (BCVA) over the course of 10 visits. BCVA corresponds to the number of letters read from a visual acuity chart. A summary of the data is given below:\n\n```         \n                                      Stratified by ARMCD\n                               Overall         CTL            TRT\n  n                             8605          4123           4482\n  USUBJID (%)\n     PT[1-1000]                 1000           494 (49.4)     506 (50.6)\n  AVISIT\n     VIS1                        983           482            501\n     VIS2                        980           481            499\n     VIS3                        960           471            489\n     VIS4                        946           458            488\n     VIS5                        925           454            471\n     VIS6                        868           410            458\n     VIS7                        816           388            428\n     VIS8                        791           371            420\n     VIS9                        719           327            392\n     VIS10                       617           281            336\n  RACE (%)\n     Asian                       297 (29.7)    151 (30.6)     146 (28.9)\n     Black or African American   317 (31.7)    149 (30.1)     168 (33.2)\n     White                       386 (38.6)    194 (39.3)     192 (37.9)\n  BCVA_BL (mean (SD))          75.12 (9.93)  74.90 (9.76)   75.40 (10.1)\n  BCVA_CHG (mean (SD))\n     VIS1                       5.59 (1.31)   5.32 (1.23)    5.86 (1.33)\n     VIS10                      9.18 (2.91)   7.49 (2.58)   10.60 (2.36)\n```\n\n# Model Implementations {.tabset}\n\nListed below are some of the most commonly used covariance structures used when fitting MMRMs. We indicate which matrices are available \"out of the box\" for each implementation considered in this vignette. Note that this table is not exhaustive; `PROC GLIMMIX` and `glmmTMB` support additional spatial covariance structures.\n\n| Covariance structures | `mmrm` | `PROC GLIMMIX` | `gls` | `lmer` | `glmmTMB` |\n|:-------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n| Ante-dependence (heterogeneous) | X | X |  |  |  |\n| Ante-dependence (homogeneous) | X |  |  |  |  |\n| Auto-regressive (heterogeneous) | X | X | X |  |  |\n| Auto-regressive (homogeneous) | X | X | X |  | X |\n| Compound symmetry (heterogeneous) | X | X | X |  | X |\n| Compound symmetry (homogeneous) | X | X | X |  |  |\n| Spatial exponential | X | X | X |  | X |\n| Toeplitz (heterogeneous) | X | X |  |  | X |\n| Toeplitz (homogeneous) | X | X |  |  |  |\n| Unstructured | X | X | X | X | X |\n\nCode for fitting MMRMs to the FEV data using each of the considered functions and covariance structures are provided below. Fixed effects for the visit number, treatment assignment and the interaction between the two are modeled.\n\n## Ante-dependence (heterogeneous)\n\n### `PROC GLIMMIX`\n\n\n\n```{=html}\n<pre><code>PROC GLIMMIX DATA = fev_data;\nCLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;\nMODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;\n<b>RANDOM AVISIT / subject=USUBJID type=ANTE(1)</b>;\n</code></pre>\n```\n\n\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula = FEV1 ~ ARMCD * AVISIT + <b>adh(VISITN | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n## Ante-dependence (homogeneous)\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula =FEV1 ~ ARMCD * AVISIT + <b>ad(VISITN | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n## Auto-regressive (heterogeneous)\n\n### `PROC GLIMMIX`\n\n\n\n```{=html}\n<pre><code>PROC GLIMMIX DATA = fev_data;\nCLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;\nMODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;\n<b>RANDOM AVISIT / subject=USUBJID type=ARH(1)</b>;\n</code></pre>\n```\n\n\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula = FEV1 ~ ARMCD * AVISIT + <b>ar1h(VISITN | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n### `gls`\n\n\n\n```{=html}\n<pre><code>gls(\n  formula = FEV1 ~ ARMCD * AVISIT,\n  data = fev_data,\n  correlation = <b>corCAR1(form = ~AVISIT | USUBJID)</b>,\n  weights = <b>varIdent(form = ~1|AVISIT)</b>,\n  na.action = na.omit\n)\n</code></pre>\n```\n\n\n\n## Auto-regressive (homogeneous)\n\n### `PROC GLIMMIX`\n\n\n\n```{=html}\n<pre><code>PROC GLIMMIX DATA = fev_data;\nCLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;\nMODEL FEV1 =  ARMCD|AVISIT / ddfm=satterthwaite solution chisq;\n<b>RANDOM AVISIT / subject=USUBJID type=AR(1)</b>;\n</code></pre>\n```\n\n\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula = FEV1 ~ ARMCD * AVISIT + <b>ar1(VISITN | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n### `gls`\n\n\n\n```{=html}\n<pre><code>gls(\n  formula = FEV1 ~ ARMCD * AVISIT,\n  data = fev_data,\n  correlation = <b>corCAR1(form = ~AVISIT | USUBJID)</b>,\n  na.action = na.omit\n)\n</code></pre>\n```\n\n\n\n### `glmmTMB`\n\n\n\n```{=html}\n<pre><code>glmmTMB(\n  FEV1 ~ ARMCD * AVISIT + <b>ar1(0 + AVISIT | USUBJID)</b>,\n  <b>dispformula = ~ 0</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n## Compound symmetry (heterogeneous)\n\n### `PROC GLIMMIX`\n\n\n\n```{=html}\n<pre><code>PROC GLIMMIX DATA = fev_data;\nCLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;\nMODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;\n<b>RANDOM AVISIT / subject=USUBJID type=CSH</b>;\n</code></pre>\n```\n\n\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula = FEV1 ~ ARMCD * AVISIT + <b>csh(VISITN | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n### `gls`\n\n\n\n```{=html}\n<pre><code>gls(\n  formula = FEV1 ~ ARMCD * AVISIT,\n  data = fev_data,\n  correlation = <b>corCompSymm(form = ~AVISIT | USUBJID)</b>,\n  weights = <b>varIdent(form = ~1|AVISIT)</b>,\n  na.action = na.omit\n)\n</code></pre>\n```\n\n\n\n### `glmmTMB`\n\n\n\n```{=html}\n<pre><code>glmmTMB(\n  FEV1 ~ ARMCD * AVISIT + <b>cs(0 + AVISIT | USUBJID)</b>,\n  <b>dispformula = ~ 0</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n## Compound symmetry (homogeneous)\n\n### `PROC GLIMMIX`\n\n\n\n```{=html}\n<pre><code>PROC GLIMMIX DATA = fev_data;\nCLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;\nMODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;\n<b>RANDOM AVISIT / subject=USUBJID type=CS</b>;\n</code></pre>\n```\n\n\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula = FEV1 ~ ARMCD * AVISIT + <b>cs(VISITN | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n### `gls`\n\n\n\n```{=html}\n<pre><code>gls(\n  formula = FEV1 ~ ARMCD * AVISIT,\n  data = fev_data,\n  correlation = <b>corCompSymm(form = ~AVISIT | USUBJID)</b>,\n  na.action = na.omit\n)\n</code></pre>\n```\n\n\n\n## Spatial exponential\n\n### `PROC GLIMMIX`\n\n\n\n```{=html}\n<pre><code>PROC GLIMMIX DATA = fev_data;\nCLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;\nMODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;\n<b>RANDOM / subject=USUBJID type=sp(exp)(visitn)</b> rcorr;\n</code></pre>\n```\n\n\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula = FEV1 ~ ARMCD * AVISIT + <b>sp_exp(VISITN | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n### `gls`\n\n\n\n```{=html}\n<pre><code>gls(\n  formula = FEV1 ~ ARMCD * AVISIT,\n  data = fev_data,\n  correlation = <b>corExp(form = ~AVISIT | USUBJID)</b>,\n  weights = varIdent(form = ~1|AVISIT),\n  na.action = na.omit\n)\n</code></pre>\n```\n\n\n\n### `glmmTMB`\n\n\n\n```{=html}\n<pre><code># NOTE: requires use of coordinates\nglmmTMB(\n  FEV1 ~ ARMCD * AVISIT + <b>exp(0 + AVISIT | USUBJID)</b>,\n  <b>dispformula = ~ 0</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n## Toeplitz (heterogeneous)\n\n### `PROC GLIMMIX`\n\n\n\n```{=html}\n<pre><code>PROC GLIMMIX DATA = fev_data;\nCLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;\nMODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;\n<b>RANDOM AVISIT / subject=USUBJID type=TOEPH</b>;\n</code></pre>\n```\n\n\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula = FEV1 ~ ARMCD * AVISIT + <b>toeph(AVISIT | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n### `glmmTMB`\n\n\n\n```{=html}\n<pre><code> glmmTMB(\n  FEV1 ~ ARMCD * AVISIT + <b>toep(0 + AVISIT | USUBJID)</b>,\n  <b>dispformula = ~ 0</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n## Toeplitz (homogeneous)\n\n### `PROC GLIMMIX`\n\n\n\n```{=html}\n<pre><code>PROC GLIMMIX DATA = fev_data;\nCLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;\nMODEL FEV1 = AVISIT|ARMCD / ddfm=satterthwaite solution chisq;\n<b>RANDOM AVISIT / subject=USUBJID</b> <b>type=TOEP</b>;\n</code></pre>\n```\n\n\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula = FEV1 ~ ARMCD * AVISIT + <b>toep(AVISIT | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n## Unstructured\n\n### `PROC GLIMMIX`\n\n\n\n```{=html}\n<pre><code>PROC GLIMMIX DATA = fev_data;\nCLASS AVISIT(ref = 'VIS1') ARMCD(ref = 'PBO') USUBJID;\nMODEL FEV1 = ARMCD|AVISIT / ddfm=satterthwaite solution chisq;\n<b>RANDOM AVISIT / subject=USUBJID</b> <b>type=un</b>;\n</code></pre>\n```\n\n\n\n### `mmrm`\n\n\n\n```{=html}\n<pre><code>mmrm(\n  formula = FEV1 ~ ARMCD * AVISIT + <b>us(AVISIT | USUBJID)</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n### `gls`\n\n\n\n```{=html}\n<pre><code>gls(\n  formula = FEV1 ~  ARMCD * AVISIT,\n  data = fev_data,\n  correlation = <b>corSymm(form = ~AVISIT | USUBJID)</b>,\n  weights = varIdent(form = ~1|AVISIT),\n  na.action = na.omit\n)\n</code></pre>\n```\n\n\n\n### `lmer`\n\n\n\n```{=html}\n<pre><code>lmer(\n  FEV1 ~ ARMCD * AVISIT + <b>(0 + AVISIT | USUBJID)</b>,\n  data = fev_data,\n  control = lmerControl(check.nobs.vs.nRE = \"ignore\"),\n  na.action = na.omit\n)\n</code></pre>\n```\n\n\n\n### `glmmTMB`\n\n\n\n```{=html}\n<pre><code>glmmTMB(\n  FEV1 ~ ARMCD * AVISIT + <b>us(0 + AVISIT | USUBJID)</b>,\n  <b>dispformula = ~ 0</b>,\n  data = fev_data\n)\n</code></pre>\n```\n\n\n\n# Benchmarking\n\nNext, the MMRM fitting procedures are compared using the FEV and BCVA datasets. FEV1 measurements are modeled as a function of race, treatment arm, visit number, and the interaction between the treatment arm and the visit number. Change in BCVA is assumed to be a function of race, baseline BCVA, treatment arm, visit number, and the treatment--visit interaction. In both datasets, repeated measures are modeled using an unstructured covariance matrix. The implementations' convergence times are evaluated first, followed by a comparison of their estimates. Finally, we fit these procedures on simulated BCVA-like data to assess the impact of missingness on convergence rates.\n\n## Convergence Times\n\n### FEV Data\n\nThe `mmrm`, `PROC GLIMMIX`, `gls`, `lmer`, and `glmmTMB` functions are applied to the FEV dataset 10 times. The convergence times are recorded for each replicate and are reported in the table below.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: Comparison of convergence times: milliseconds\n\n|Implementation | Median| First Quartile| Third Quartile|\n|:--------------|------:|--------------:|--------------:|\n|mmrm           |  56.15|          55.76|          56.30|\n|PROC GLIMMIX   | 100.00|         100.00|         100.00|\n|lmer           | 247.02|         245.25|         257.46|\n|gls            | 687.63|         683.50|         692.45|\n|glmmTMB        | 715.90|         708.70|         721.57|\n\n\n:::\n:::\n\n\n\nIt is clear from these results that `mmrm` converges significantly faster than other R functions. Though not demonstrated here, this is generally true regardless of the sample size and covariance structure used. `mmrm` is faster than `PROC GLIMMIX`.\n\n### BCVA Data\n\nThe MMRM implementations are now applied to the BCVA dataset 10 times. The convergence times are presented below.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: Comparison of convergence times: seconds\n\n|Implementation | Median| First Quartile| Third Quartile|\n|:--------------|------:|--------------:|--------------:|\n|mmrm           |   3.36|           3.32|           3.46|\n|glmmTMB        |  18.65|          18.14|          18.87|\n|PROC GLIMMIX   |  36.25|          36.17|          36.29|\n|gls            | 164.36|         158.61|         165.93|\n|lmer           | 165.26|         157.46|         166.42|\n\n\n:::\n:::\n\n\n\nWe again find that `mmrm` produces the fastest convergence times on average.\n\n## Marginal Treatment Effect Estimates Comparison\n\nWe next estimate the marginal mean treatment effects for each visit in the FEV and BCVA datasets using the MMRM fitting procedures. All R implementations' estimates are reported relative to `PROC GLIMMIX`'s estimates. Convergence status is also reported.\n\n### FEV Data\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](../images/mmrm/review-treatment-fev-1.png){width=100%}\n:::\n:::\n\n\n\nThe R procedures' estimates are very similar to those output by `PROC GLIMMIX`, though `mmrm` and `gls` generate the estimates that are closest to those produced when using SAS. All methods converge using their default optimization arguments.\n\n### BCVA Data\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](../images/mmrm/review-treatment-bcva-1.png){width=100%}\n:::\n\n::: {.cell-output-display}\n![](../images/mmrm/review-treatment-bcva-2.png){width=100%}\n:::\n:::\n\n\n\n`mmrm`, `gls` and `lmer` produce estimates that are virtually identical to `PROC GLIMMIX`'s, while `glmmTMB` does not. This is likely explained by `glmmTMB`'s failure to converge. Note too that `lmer` fails to converge.\n\n## Impact of Missing Data on Convergence Rates\n\nThe results of the previous benchmark suggest that the amount of patients missing from later time points affect certain implementations' capacity to converge. We investigate this further by simulating data using a data-generating process similar to that of the BCVA datasets, though with various rates of patient dropout.\n\nTen datasets of 200 patients are generated each of the following levels of missingness: none, mild, moderate, and high. In all scenarios, observations are missing at random. The number patients observed at each visit is obtained for one replicated dataset at each level of missingness is presented in the table below.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: Number of patients per visit\n\n|      | none|  mild| moderate|  high|\n|:-----|----:|-----:|--------:|-----:|\n|VIS01 |  200| 196.7|    197.6| 188.1|\n|VIS02 |  200| 195.4|    194.4| 182.4|\n|VIS03 |  200| 195.1|    190.7| 175.2|\n|VIS04 |  200| 194.1|    188.4| 162.8|\n|VIS05 |  200| 191.6|    182.5| 142.7|\n|VIS06 |  200| 188.2|    177.3| 125.4|\n|VIS07 |  200| 184.6|    168.0| 105.9|\n|VIS08 |  200| 178.5|    155.4|  82.6|\n|VIS09 |  200| 175.3|    139.9|  58.1|\n|VIS10 |  200| 164.1|    124.0|  39.5|\n\n\n:::\n:::\n\n\n\nThe convergence rates of all implementations for stratified by missingness level is presented in the plot below.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](../images/mmrm/review-convergence-rate-missingness-1.png){width=100%}\n:::\n:::\n\n\n\n`mmrm`, `gls`, and `PROC GLIMMIX` are resilient to missingness, only exhibiting some convergence problems in the scenarios with the most missingness. These implementations converged in all the other scenarios' replicates. `glmmTMB`, on the other hand, has convergence issues in the no-, mild-, and high-missingness datasets, with the worst convergence rate occurring in the datasets with the most dropout. Finally, `lmer` is unreliable in all scenarios, suggesting that it's convergence issues stem from something other than the missing observations.\n\nNote that the default optimization schemes are used for each method; these schemes can be modified to potentially improve convergence rates.\n\nA more comprehensive simulation study using data-generating processes similar to the one used here is outlined in the [`simulations/missing-data-benchmarks`](https://github.com/openpharma/mmrm/tree/main/simulations/missing-data-benchmarks) subdirectory. In addition to assessing the effect of missing data on software convergence rates, we also evaluate these methods' fit times and empirical bias, variance, 95% coverage rates, type I error rates and type II error rates. `mmrm` is found to be the most most robust software for fitting MMRMs in scenarios where a large proportion of patients are missing from the last time points. Additionally, `mmrm` has the fastest average fit times regardless of the amount of missingness. All implementations considered produce similar empirical biases, variances, 95% coverage rates, type I error rates and type II error rates.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}